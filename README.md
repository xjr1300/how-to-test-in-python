# テストの考え方と実装方法 in Python

[単体テストの考え方／使い方](https://book.mynavi.jp/ec/products/detail/id=134252)

![書籍表紙](https://book.mynavi.jp/files/topics/134252_ext_06_0.jpg?v=1670578534)

本文書では、**古典学派 (デトロイト学派) の解釈を採用**しています。
また、本文書では、書籍を参考に個人的な意見を含めているため、書籍の内容と異なる場合があります。

本文書の内容について納得できない箇所があれば、書籍を参照してその違いを確認してください。

- [テストの考え方と実装方法 in Python](#テストの考え方と実装方法-in-python)
  - [テストの種類](#テストの種類)
    - [単体テスト (Unit Test) の概要](#単体テスト-unit-test-の概要)
    - [統合テスト (Integration Test) の概要](#統合テスト-integration-test-の概要)
    - [E2E (End to End Test) の概要](#e2e-end-to-end-test-の概要)
  - [テストを実装する理由](#テストを実装する理由)
  - [共有依存 (shared dependency)](#共有依存-shared-dependency)
  - [プライベート依存 (private dependency)](#プライベート依存-private-dependency)
    - [プライベートな不変依存](#プライベートな不変依存)
      - [値オブジェクト (value object)](#値オブジェクト-value-object)
    - [プライベートな可変依存](#プライベートな可変依存)
  - [プロセス外依存](#プロセス外依存)
    - [管理下にある依存 (managed dependency)](#管理下にある依存-managed-dependency)
    - [管理下にないプロセス外依存 (unmanaged dependency)](#管理下にないプロセス外依存-unmanaged-dependency)
  - [テストの品質の維持](#テストの品質の維持)
  - [網羅率](#網羅率)
    - [コード網羅率 (code coverage)](#コード網羅率-code-coverage)
    - [分岐網羅率 (branch coverage)](#分岐網羅率-branch-coverage)
    - [網羅率をテストスイートの品質としてはいけない理由](#網羅率をテストスイートの品質としてはいけない理由)
  - [品質の良いテストスイートの条件](#品質の良いテストスイートの条件)
    - [テストすることが開発サイクルの中に組み込まれている](#テストすることが開発サイクルの中に組み込まれている)
    - [コードベースの特に重要な部分のみがテスト対象になっている](#コードベースの特に重要な部分のみがテスト対象になっている)
    - [最小限の保守コストで最大限の価値を生み出すようになっている](#最小限の保守コストで最大限の価値を生み出すようになっている)
  - [単体テスト](#単体テスト)
    - [単体テストに求められる要件](#単体テストに求められる要件)
    - [単体テストの構造](#単体テストの構造)
      - [1つのフェーズが複数存在する場合](#1つのフェーズが複数存在する場合)
      - [分岐がある場合](#分岐がある場合)
      - [実行フェーズが1行以上になる場合](#実行フェーズが1行以上になる場合)
      - [テスト後の後始末](#テスト後の後始末)
      - [テスト対象システムの変数名](#テスト対象システムの変数名)
      - [テスト対象の振る舞いの中に分岐がある場合](#テスト対象の振る舞いの中に分岐がある場合)
      - [単体テストの名前](#単体テストの名前)
    - [単体テストの要件](#単体テストの要件)
      - [単体テストの4つの柱](#単体テストの4つの柱)
        - [退行 (regression) に対する保護](#退行-regression-に対する保護)
        - [リファクタリングへの耐性](#リファクタリングへの耐性)
        - [迅速なフィードバック](#迅速なフィードバック)
        - [保守のしやすさ](#保守のしやすさ)
      - [理想的な単体テスト](#理想的な単体テスト)
      - [取るに足らないテスト](#取るに足らないテスト)
    - [ブラックボックステスト](#ブラックボックステスト)
  - [モック](#モック)
    - [テストダブルの種類](#テストダブルの種類)
      - [モック](#モック-1)
      - [スタブ](#スタブ)
    - [コマンド・クエリ分離の原則 (CQS: Command Query Separation)とモックとスタブ](#コマンドクエリ分離の原則-cqs-command-query-separationとモックとスタブ)
  - [単体テストの手法](#単体テストの手法)
    - [出力値ベーステスト](#出力値ベーステスト)
    - [状態ベーステスト](#状態ベーステスト)
    - [コミュニケーションベーステスト](#コミュニケーションベーステスト)
  - [関数型アーキテクチャ](#関数型アーキテクチャ)
    - [関数型プログラミング](#関数型プログラミング)
    - [関数型アーキテクチャ](#関数型アーキテクチャ-1)
    - [出力値ベーステーストへの移行](#出力値ベーステーストへの移行)
      - [サンプルプロジェクト（訪問者記録システム、vls: Visitor Logging System）](#サンプルプロジェクト訪問者記録システムvls-visitor-logging-system)
      - [ファイルシステムをスタブ／モックに置き換える](#ファイルシステムをスタブモックに置き換える)
      - [関数型アーキテクチャへのリファクタリング](#関数型アーキテクチャへのリファクタリング)
      - [関数型アーキテクチャを採用できないテストケース](#関数型アーキテクチャを採用できないテストケース)
  - [リファクタリング](#リファクタリング)
    - [リファクタリングが必要なコードの識別](#リファクタリングが必要なコードの識別)
      - [ドメインモデル／アルゴリズム](#ドメインモデルアルゴリズム)
      - [取るに足らないコード](#取るに足らないコード)
      - [コントローラー](#コントローラー)
      - [過度に複雑なコード](#過度に複雑なコード)
      - [質素なオブジェクト (Humble Object) を利用した過度に複雑なコードの分割](#質素なオブジェクト-humble-object-を利用した過度に複雑なコードの分割)
      - [サンプルプロジェクト (ユーザー管理システム) について](#サンプルプロジェクト-ユーザー管理システム-について)
      - [ユーザー管理システムのリファクタリング](#ユーザー管理システムのリファクタリング)
    - [ドメインイベントの導入](#ドメインイベントの導入)
  - [統合テスト (integration test)](#統合テスト-integration-test)
    - [統合テストの実装](#統合テストの実装)
    - [統合テストと早期失敗 (Fail First)](#統合テストと早期失敗-fail-first)
    - [統合テストにおけるプロセス外依存の取り扱い](#統合テストにおけるプロセス外依存の取り扱い)
      - [管理下にある依存と管理下にない依存の両方の性質を持つプロセス外依存の取り扱い](#管理下にある依存と管理下にない依存の両方の性質を持つプロセス外依存の取り扱い)
      - [統合テストで実際のデータベースを利用できない場合](#統合テストで実際のデータベースを利用できない場合)
    - [統合テストの作成](#統合テストの作成)
    - [参考: 静的型付け言語におけるインターフェイスを利用したプロセス外依存の抽象化](#参考-静的型付け言語におけるインターフェイスを利用したプロセス外依存の抽象化)
    - [1つのテストケースで複数の実行フェーズを持つ統合テスト](#1つのテストケースで複数の実行フェーズを持つ統合テスト)
    - [ログの出力テスト](#ログの出力テスト)
      - [ログの分類](#ログの分類)
      - [サポートログの出力](#サポートログの出力)
      - [診断ログの出力](#診断ログの出力)

## テストの種類

- `単体テスト (Unit Test)`
- `統合テスト (Integration Test)`
- `E2Eテスト (End to End Test)`

![テストピラミッド](./images/test-pyramid.png)

### 単体テスト (Unit Test) の概要

- **テストの実行が自動化**されていること
- **1単位の振る舞い (a unit of behavior)** を検証すること
- **実行時間が短い**こと
- **他のテストケースから隔離**して実行できること

単体テストでは、関数やクラスのメソッドなど、**1つの振る舞い**を検証します。

また、実行時間を短くすることで、**繰り返し単体テストを実行**できるように開発者の負担を軽減します。
実行時間が長くなると、開発者がテストを実行する回数が減り、バグを見つけるまでの時間が長くなります。
バグが見つかるまでの時間が長くなると、それまでにコードベースは大きくなるため、バグの特定と修正に時間がかかるようになります。

さらに、それぞれの単体テストが他の単体テストから独立することで、他からの影響を受けず、個別に実行できるようになります。
これにより、単体テストを**個別に実行**したり、同時に複数の単体テストを**並行／並列で実行**することができます。

### 統合テスト (Integration Test) の概要

統合テストは、システム全体が意図したように機能することを検証するテストです。
システムの`ユースケース`ごとに、統合テストを実装して、それぞれを単独または連続して実行します。

### E2E (End to End Test) の概要

E2Eテストは、統合テストの上位に位置するテストです。
統合テストでは、システムが依存するメール送信サービスなどの外部サービスをテストダブルに置き換えますが、E2Eテストは、ほぼすべての依存を実際のサービスを使用してテストします。

E2Eテストは、本書の説明対象外とします。

## テストを実装する理由

テストを実装する理由は、システムが**将来も持続的に成長できるようにするため**です。

なお、テストが実装されているシステムのことを`テスト対象システム (SUT: System Under Test)`と呼びます。

ほとんどのシステムは、リリース後に何度も仕様変更や改修が行われ、その中で`リファクタリング`されます。
SUTの仕様変更や改修は、単体／統合テストを実行することで、変更が変更されていない部分に影響を与えないことを確認できます。
変更によりシステムに不具合が発生することを`退行 (regression)`と呼びます。
SUTは、この退行を防ぐことができ、仕様変更や改修に対する開発者の負担を軽減します。

逆に、SUTでないシステムの変更は、変更がシステムに影響を与えているかを確認する工数が多くなり、開発者の負担が大きくなります。
この負担は、開発者のモチベーションを下げ、システムを変更しない理由となり、**システムの成長を妨げます**。

システムのコードベースは、リリース直後から成長を開始して劣化する傾向があり、エントロピー（無秩序の量）が増大します。
このため、リファクタリングが必要になりますが、SUTはリファクタリングによる退行を生み出す可能性が低くなり、リファクタリングに対する開発者の心理的不安を減らすことができます。

逆に、一時的に作成するプログラムなど、成長しない／成長を見込めないシステム（プログラム）は、簡易的なテストで済ましたり、テストの実装を省くことができると考えられます。

次の図は、プロダクションコードとテストコードをリファクタリングなどで適切に保守したSUTとそうでないシステムの、システムの成長と実装に費やす時間を示しています。
初期はSUTの方が実装に費やす時間が大きくなりますが、コードベースが大きくなるにつれて、SUTの方が実装に費やす時間が少なくなります。

![プロジェクトの成長](./images/project-growth.png)

## 共有依存 (shared dependency)

`共有依存 (shared dependency)`とは、データベースなどテストケース間で共有される依存を示します。
共有依存を扱うテストケースを同時に実行すると、お互いがテストに影響を与えるため、正常にテストが実行されなくなる場合があります。

単体テストにおいて、共有依存を`モック`や`スタブ`などの`テストダブル`に置き換えることで、単体テスト同士が影響を与えないようにします。
テストダブルについては、後で説明します。

## プライベート依存 (private dependency)

`プライベート依存 (private dependency)`とは、テストケースで共有されない依存で、`可変依存`と`不変依存`があります。

単体テストにおいて、プライベート依存は、1つのテスト対象オブジェクトからしか参照されないため、テストダブルで置き換えずそのまま使用します。

### プライベートな不変依存

データが不変で、1つのテスト対象オブジェクトからしか使用されない場合、`プライベートな不変依存`となります。
プライベートな不変依存には、`値オブジェクト (value object)`などがあります。

#### 値オブジェクト (value object)

`ドメイン駆動設計 (Domain Driven Design: DDD`における値オブジェクトは、次の特徴を持ちます。

- 不変 (immutable: イミュータブル)
- 同一性を持たない (IDや識別子を持たない)
  - 同じ属性を持つ値オブジェクトは等価である
- 小さい属性の集合

`value_objects`モジュールに、住所を表現する値オブジェクトをクラスで、色を表現する値オブジェクト列挙型で示したため参照してください。

### プライベートな可変依存

データが可変で、1つのテスト対象オブジェクトからしか参照されない場合、`プライベートな可変依存`となります。
プライベートな可変依存には、ファイルシステムに作成された、1つのテスト対象オブジェクトからしか参照されないファイルなどがあります。

## プロセス外依存

システムは、データベースやメール配信サービスなど、システムが動作するプロセスとは異なるプロセスで動作する`プロセス外依存`があります。
このプロセス外依存は、次の2つに分類されます。

- `管理下にあるプロセス外依存 (managed dependency)`
- `管理下にないプロセス外依存 (unmanaged dependency)`

### 管理下にある依存 (managed dependency)

`管理下にあるプロセス外依存`は、SUTしかアクセスしないデータベースなど、SUTが自由に操作でき、その振る舞いを確認できる依存を示します。

単体テストでは、管理下にある依存をテストダブルで置き換え、テストの実行時間を短くします。
一方、統合テストでは、管理下にある依存を実際に利用したテストを実装します。

### 管理下にないプロセス外依存 (unmanaged dependency)

`管理下にないプロセス外依存`は、外部サービスなど、費用や過度に負荷を与えることができないなどの理由でSUTが自由に操作できない依存を示します。
管理下にない依存は、単体テスト及び統合テストでテストダブルに置き換えます。

## テストの品質の維持

テストの品質が悪いとは次の状態を指します。

- エラーが発生してテストを実行できない
- `偽陽性 (False Positive)` が発生する
  - プロダクションコードが正しいにも関わらず、テストに失敗する
- `偽陰性 (False Negative)` が発生する
  - プロダクションコードが誤っているにも関わらず、テストに成功する

テストの品質が悪いとテストが信頼されなくなり、テストが実行されなくなった結果、**システムの持続的な成長が阻害**されます。

よって、テストの品質を維持するためには、次を心がける必要があります。

- プロダクションコードのリファクタリングに合わせて、テストをリファクタリングする。
- プロダクションコードを変更するたびに、テストを実行する。
- テストが偽陽性や偽陰性を発生した場合は、修正する。

テストコードのリーディングは、プロダクションコードがどのように振舞っているかを把握するために非常に役に立ちます。
よって、プロダクションコードだけでなくテストコードの品質も維持する必要があります。

## 網羅率

`テストスイート（テスト全体）`の品質を評価する指標として`網羅率`があります。
一般的に、網羅率を高く維持することが求められますが、網羅率は**テストスイートの品質が悪いことを評価できますが、良いことを評価できません**。
つまり、**網羅率が低いときのみ、テストスイートの品質が悪いと評価できます**。
逆に、**網羅率が高い場合に、テストスイートの品質が良いとは評価できません**。

網羅率には次の2つがあります。

- `コード網羅率 (code coverage)`
- `分岐網羅率 (branch coverage)`

### コード網羅率 (code coverage)

コード網羅率は、テストスイートがプロダクションコードの行をどれだけ実行したかで計算されます。

$コード網羅率 = \frac{テストスイートが実行した行数}{プロダクションコードの行数}$

次の`is_string_long`関数のコード網羅率を考えます。

```python
def is_string_long(s: str) -> bool:   # 1
    if len(s) > 5:                    # 2
        return True                   # 3
    return False                      # 4

import unittest
class TestIsStringLong(unittest.TestCase):
    def test_is_string_long(self):
        result = is_string_long("abc")
        self.assertFalse(result)
```

上記の場合、`len(s)`は`3`であるため、1, 3, 4行目が実行され、コード網羅率は0.75 (3 / 4)になります。

しかし、`is_string_long`関数を次に変更したとき、コード網羅率は1.0になります。
プロダクションコードのリファクタリングによりテストの品質は向上していませんが、コード網羅率は0.75から1.0に向上しています。

```python
def is_string_long(s: str) -> bool:
    return True if len(s) > 5 else False
```

**コード網羅率はプロダクションコードの実装方法で結果が変わる**ため、コード網羅率だけでテストスイートの品質を判断することはできません。

### 分岐網羅率 (branch coverage)

分岐網羅率は、テストスイートがプロダクションコードに存在する分岐した経路を、どれだけ実行したかで計算されます。

$分岐網羅率 = \frac{テストスイートが実行した分岐数}{プロダクションコードの分岐数}$

リファクタリング前後の`is_string_long`関数の分岐網羅率はどちらも0.5です。

ここで、次のように関数から返された結果を検証しない**邪悪な**`確認不在のテスト`を実装すると、分岐網羅率は1.0になります。

```python
class TestIsStringLong(unittest.TestCase):
    def test_is_string_short(self):
        result = is_string_long("abc")
        # アサーションがななく、関数から返された結果を検証していない

    def test_is_string_long(self):
        result = is_string_long("abcdef")
        # アサーションがななく、関数から返された結果を検証していない
```

上記のテストは、`is_string_long`関数の分岐をすべて実行していますが、関数の結果である`result`を評価していません。

### 網羅率をテストスイートの品質としてはいけない理由

網羅率をテストスイートの品質としてはならない理由は次の通りです。

- プロダクションコードの実装方法によってコード網羅率が変わる
- 分岐網羅率を増やすために、確認不在のテストが実装される

基本的に網羅率を高く維持されていれば、**テストされている**とみなせます。
しかし、網羅率を例えば85%以上に維持するなど、数値目標を設定することは、開発者に**人工的な目標**を設定することになり、テストスイートの品質を向上させることに繋がりません。

## 品質の良いテストスイートの条件

- **テストすることが開発サイクルの中に組み込まれている**
- **コードベースの特に重要な部分のみがテスト対象になっている**
- **最小限の保守コストで最大限の価値を生み出している**

### テストすることが開発サイクルの中に組み込まれている

テストは常に実行されなければならず、テストの実行が開発サイクルの中に組み込まれていなくてはなりません。
理想的には、仮に些細な変更であっても、コードが変更されるたびにテストが実施されるようになっていることです。
**テストは実行されて、初めて価値を持ちます**。

チーム開発している場合、リモートリポジトリの`develop`または`main`ブランチにプッシュされるたびに、`CI/CDパイプライン`が自動で実行されることが望ましいです。

### コードベースの特に重要な部分のみがテスト対象になっている

ほとんどのシステムにおいて、システムの核はビジネスロジックを含むコードで、それらは**ドメイン**または**ドメインモデル**と呼ばれます。
テストの実装及び実行に費やした時間が価値として効果的に得られるのは、ドメインに対するテストです。

逆に価値の低いコードには、次などが挙げられます。

- インフラに関するコード
- フレームワーク、ライブラリ、データベースまたは外部サービスなど依存関係に関するコード
- インターフェイスなど、構成要素同士を結びつけるコード

ドメインをテストしやすくするために、**ドメインは価値の低いコードと分離**する（`疎結合`にする）必要があります。
また、テストの価値を高めるために、**ドメインとドメイン以外を区別する能力**を発揮して、価値の高いテストを優先して実装するようにしてください。

### 最小限の保守コストで最大限の価値を生み出すようになっている

単体テストにおいて、最小限の保守コストで最大限の価値を生み出すことは非常に難しいです。
これをできるようになるためには、次の能力が必要です。

- 価値のあるテストケースを認識できること
  - 逆に、価値の低いテストケースを認識できること
- 価値のあるテストケースを作成できること

価値のあるテストケースを認識することと、作成できることは異なる能力です。

## 単体テスト

**単体テストは、ビジネスシナリオにおけるハッピーパスと可能な限り多くの異常ケース検証**します。

ここで、ハッピーパスとは、ビジネスシナリオが正常に終わる実行経路を示します。
また、異常ケースとは、ビジネスシナリオの実行がエラーで終わる場合を示します。

### 単体テストに求められる要件

繰り返しになりますが、古典学派 (デトロイト学派) の解釈において、単体テストには次の要件が必要です。

- テストの実行が自動化されていること
- 1単位の振る舞い (a unit of behavior) を検証すること
- 実行時間が短いこと
- 他のテストケースから隔離して実行できること

### 単体テストの構造

単体テストは、次で構成される`AAAパターン`で実装します。

- `準備 (Arrange)`
- `実行　(Act)`
- `検証　(Assert)`

```python
# calculator/__main__.py
import unittest


# プロダクションコード
class Calculator:
    """計算機クラス"""

    def add(self, a: int, b: int) -> int:
        """2つの整数を足し算した結果を返す。

        Args:
            a (int): 演算子の左辺の値
            b (int): 演算子の右辺の値

        Returns:
            int: 2つの整数を足し算した結果
        """
        return a + b


# テストコード
class CalculatorTest(unittest.TestCase):
    """計算機テストクラス"""

    def test_add_two_numbers(self) -> None:
        """2つの整数を足した結果が正しいことを確認するテスト"""
        # 準備 (Arrange)
        calculator = Calculator()
        a = 1
        b = 2

        # 実行 (Act)
        result = calculator.add(a, b)

        # 検証 (Assert)
        self.assertEqual(result, 3)


if __name__ == "__main__":
    unittest.main()
```

準備フェーズでは、テストケースの事前条件を満たすようにSUTとその依存の状態を設定します。

実行フェーズでは、メソッドや関数を呼び出しなど、SUTの振る舞いを実行します。
SUTから結果が返ってくる場合は、その結果を変数に格納します。

検証フェーズでは、SUTの振る舞いの結果が期待通りであるかを確認します。
振る舞いの結果には次などがあります。

- SUTからの戻り値
- SUTが振る舞った後の、SUTの状態
- SUTが振る舞った後の、協力者オブジェクトの状態
- SUTが振る舞った後の、協力者オブジェクトのメソッドまたは関数の呼び出し回数

#### 1つのフェーズが複数存在する場合

1つのフェーズが複数存在するテストケースは、1単位の振る舞いではなく**複数の振る舞い**を検証していない可能性があります。
この場合、テストケースを分割して、1単位の振る舞いを検証するようにします。

テストケースを分割できない場合、そのテストを結合テストとして実装した方が適切な場合があります。

#### 分岐がある場合

分岐があるテストケースは、1単位の振る舞いを検証していない可能性があります。
この場合、分岐の数だけテストケースを分割して、それぞれのテストケースで1単位の振る舞いを検証するようにします。

#### 実行フェーズが1行以上になる場合

通常、実行フェーズのコードは1行です。
もし、実行フェーズが複数行になった場合、SUTのメソッドなどのAPIが適切でない可能性があります。
この場合、SUTをリファクタリングして、それぞれのメソッドが1単位の振る舞いをするように改善します。

テストの実装が煩雑になる場合、***SUTの設計が適切でない***可能性があります。

次の単体テストでは、実行フェーズで購入と在庫の更新を行っています。
もし、開発者が購入するAPIを発行した後、在庫を更新するAPIを発行しなかった場合、のドメイン`不変条件`が破られ、システムの在庫管理が破綻します。
なお、不変条件とは、**常に成立しなくてはならない条件**を示します。

$購入前の在庫数 = 購入後の在庫数 + 購入数$

よって、`Customer`クラスの`purchase`メソッドは、購入する商品、購入する商品数及び店舗を受け取り、そのメソッドの中で在庫の更新をする必要があります。

```python
# 実行フェーズが1行以上になり、SUTの設計が適切でないケース
class PurchaseTest(unittest.TestCase):
    def test_purchase_succeeds_when_enough_inventory(self) -> None:
        """在庫が十分にあるときに、購入が成功することを確認"""
        # 準備
        store = Store()
        store.add_inventory(Product.SHAMPOO, 10)
        customer = Customer()

        # 実行
        success = customer.purchase(store, Product.SHAMPOO, 5)  # 購入
        store.remove_inventory(Product.SHAMPOO, 5) # 在庫の更新

        # 確認
        self.assertTrue(success)
        self.assertEqual(5, store.get_inventory(Product.SHAMPOO))
```

#### テスト後の後始末

基本的に、単体テストは、プロセス外依存ではなくそれを置き換えたテストダブルとやり取りするため、テスト後の後始末は必要ありません。
後始末が必要なテストがある場合、そのテストを統合テストとして実装することを検討してください。

#### テスト対象システムの変数名

多くの依存を扱う単体テストでは、単体テストのコードでテスト対象システムと依存を区別することが難しくなる場合があります。
テスト対象システムには、`sut`という変数を使用することを検討してください。

#### テスト対象の振る舞いの中に分岐がある場合

SUTの振る舞いの中に分岐がある場合、分岐の数だけテストケースを実装することになります。
このとき、準備フェーズにおけるSUTや依存の準備が煩雑な場合、それぞれのテストケースで煩雑な準備をするのではなく、それらを準備する`ヘルパー関数`を実装して、**単体テスト間で共有**するようにしてください。

ヘルパー関数により、単体テストのコードが簡潔になり、保守性が向上するとともに見通しが良くなります。

#### 単体テストの名前

単体テストに名前をつけるときの指針を次に示します。

- DDDにおいて`ビジネスエキスパート`と呼ばれる問題領域に精通する非開発者が、どのようなことを検証しているかが伝わるような名前をつける
- 英語で名前をつける場合は、`_`で単語を区切る
- 厳密な命名規則に縛られないようにする

`<メソッド名>_<事前条件>_<予期した結果>`のような命名規則がありますが、この命名方法は振る舞いではなく**実装の詳細に着目しているため適切ではありません**。
基本的に、SUTの**メソッドや関数の名前をテスト名に含めない**ようにしてください。

```python
class CalculatorTest(unittest.TestCase):
    def test_add_two_numbers(self) -> None:
        """2つの数値を加算することを確認"""
        # テストコード

    def test_add_two_numbers_returns_sum(self) -> None:
        """2つの数値を加算した結果を返すことを確認"""
        # テストコード


class DeliveryDispatcherTest(unittest.TestCase):
    def test_delivery_with_invalid_date_should_be_considered_invalid(self) -> None:
        """無効な日付が指定された配達は不正だと見做されるべきであることを確認"""
        # テストコード

    def test_is_delivery_valid_invalid_date_returns_false(self) -> None:
        """is_delivery_validメソッドは無効な日付を渡したときFalseを返すことを確認"""
        # テストコード
```

上記、それぞれのテストクラスの1つ目の名前は、振る舞いを簡潔に表現する適切な名前と考えられます。
しかし、2つ目の名前は、実装の詳細を表現しており、テストでどのような振る舞いを検証しているか把握することが難しくなっています。

### 単体テストの要件

#### 単体テストの4つの柱

- **退行 (regression) に対する保護**
- **リファクタリングへの耐性**
- **迅速なフィードバック**
- **保守のしやすさ**

テストの正確性は、次のように判定されます。

![テストの正確性](./images/test-accuracy.png)

偽陰性に対しては、退行に対する保護を可能な限り備えるようにします。
偽陽性に対しては、リファクタリングへの耐性を可能な限り備えるようにします。

##### 退行 (regression) に対する保護

単体テストを実装することで、新しい機能を追加した後に、変更されていない部分にバグが生じていないか (退行を発生させていないか) 確認します。
もし、プロダクションコードに退行が発生した場合、単体テストに失敗するため、すぐに退行に対応できます。

単体テストを実装することで、プロダクションコードを変更しても退行が発生しないことに自信を持てるようになり、**システムの持続的な成長を期待できます**。

退行に対する保護を最大限に備えるためには、**テストで可能な限り多くのプロダクションコードを実行**して、**コード網羅率を高く維持**する必要があります。

##### リファクタリングへの耐性

`リファクタリングへの耐性`とは、テストが失敗することなく、プロダクションコードをリファクタリングできることです。

プロダクションコードをリファクタリングしたとき、そのコードに誤りがないにも関わらずテストに失敗した場合、そのテストは偽陽性を検出しています。

つまり、リファクタリングへの耐性とは、**リファクタリングしても偽陽性を検出しない性質**を指します。

ほとんどの偽陽性は、リファクタリング後に検出されます。
偽陽性をそのままにしておくと、リファクタリングやテストする意味を損ないます。
その結果、開発者はリファクタリングやテストすることを避けるようになり、問題のあるコードが本番環境に持ち込まれる可能性が高くなり、**システムの持続的な成長を阻害**します。

偽陽性を検出するテストは、`壊れやすいテスト`と呼ばれます。
壊れやすいテストは、SUTの内部実装に着目したテストになっている場合が多く、SUTの振る舞いをリファクタリングして変更した場合、テストに失敗するようになります。

壊れやすいテストの例としては、関数が生成するSQL文を検証するテストがあります。
関数が生成するSQL文を同じ結果を返す異なるSQL文にリファクタリングすると、実装の詳細に着目したテストは`偽陽性`を検出する可能性があります。

この場合、生成するSQL文を検証するテストを実装するのではなく、生成されたSQL文でデータベースに問い合わせをして、その結果を検証する`統合テスト`に変更する必要があります。

リファクタリングへの耐性を保つためには、**SUTの最終的な結果、つまり振る舞いの結果に着目してテストを実装**しなければなりません。

振る舞いの結果に着目したテストは、`ブラックボックステスト`と呼ばれます。
逆に、内部実装に着目したテストは、`ホワイトボックステスト`と呼ばれます。

また、テストケースを作成する際に最も意識すべきことは、作成するテストケースが問題領域に関する物語を表現することです。
そしてそのテストケースが失敗した場合、テストケースが表現する物語とシステムの振る舞いの間に違いがあることが明らかになり、プロダクションコードまたはテストコードの修正を促すことができます。

##### 迅速なフィードバック

単体テストの実行時間を短くすることで、テストの結果をすぐに確認できるようにします。

##### 保守のしやすさ

単体テストの保守性を維持することで、プロダクションコードが変更された場合に単体テストを変更しやすくします。

また、プロダクションコードの振る舞いを理解するために、単体テストを読みやすくします。

#### 理想的な単体テスト

退行への保護、リファクタリングへの耐性、迅速なフィードバック`に3つは互いに排反するため、これら3つをすべて兼ね揃えた単体テストを実装することはできません。

- 統合テストやE2Eテストなど、退行への保護とリファクタリングへの耐性を兼ね揃えたテストは時間がかかるため、迅速なフィードバックを期待できない
- 取るに足らないテストは、リファクタリングへの耐性と迅速なフィードバックを得られるが、基本的に退行が発生しないため、退行への保護を備える価値がない
- 壊れやすいテストは、退行への保護と迅速なフィードバックを得られるが、前述の通りリファクタリングへの耐性を備えることができない

テストケースの価値は、それぞれの要件を備えた度合いの積で表現されるため、4つの柱を備える度合いを、少なくとも0より大きくする必要があります。

$テストケースの価値 = 退行への保護 \times リファクタリングへの耐性 \times 迅速なフィードバック \times 保守のしやすさ$

また、リファクタリングへの耐性は、完全に備えるか全く備えないかの2択になるため、リファクタリングへの耐性は必ず備える必要があります。

よって、理想的な単体テストは、リファクタリングへの耐性と保守のしやすさを備えており、退行への保護と迅速なフィードバックを備える度合いを、それぞれのテストケースで調整する必要があります。

![退行への保護と迅速なフィードバックの調整](./images/adjustment-regression-feedback.png)

> 単体テストでは、時間が短いことが要件になるため、退行への保護と迅速なフィードバックを両立できます。
> しかし、統合テストでは管理可能なプロセス外依存を扱うため、テストの実行時間が長くなり、退行への保護と迅速なフィードバックを両立できない場合があります。
> 書籍では、単体テストの章で退行への保護と迅速なフィードバックの調整が示されていますが、これは統合テストまたはE2Eテストに適用される内容だと考えられます。

#### 取るに足らないテスト

取るに足らないテストとは、実装を間違えにくい`プロパティ`などを検証するテストを示します。

取るに足りない機能とそのテストは、`boring`モジュールを参照してください。

### ブラックボックステスト

ブラックボックステストは、ソフトウェアテストの一種で、ソフトウェアの内部構造や動作の仕組みを知らずに、外部から見たソフトウェアの機能を検証するテスト手法です。

ブラックボックステストでは、次などのテスト手法が用いられます。

- `同値分割法`: 入力データを成功または失敗などのグループに分け、各グループの代表的な値をテストします。
- `境界値分析`: 入力データの境界値（例えば、最大値や最小値）付近を重点的にテストします。
- `決定表`: 複雑なロジックや条件を表形式で整理し、その組み合わせをテストします。

ブラックボックステストの利点を次に示します。

- ソフトウェアの内部構造を知る必要がないため、第三者がテストを実装できます。
  - 基本的に、第三者がテストを実装することは望ましいと考えられます。
- ユーザー視点でのテストができるため、実際のユースケースで発生するバグを発見できます。

ブラックボックステストの欠点を次に示します。

- 内部構造を考慮しないため、特定のコードパスや条件を網羅的にテストできない場合があります。

同値分割法及び境界値分析を用いたブラックボックステストは、`black_box`モジュールを参照してください。

`black_box`モジュールの境界値分析を用いたテストケースでは、`境界値`となる17才と18才に加えて16才と19才のテストケースを実装しています。
これは、誤って大人を判定する式が`year == 18`と実装されていた場合に、19才を判断するテストが失敗するようにするためです。
境界値分析では境界値だけでなく境界値よりも1単位小さいまたは大きい値をテストケースに含めるようにしてください。

## モック

### テストダブルの種類

テストダブルは、次の2つの種類に分類できます。

- `モック`
- `スタブ`

![モックとスタブ](./images/mock-and-stub.png)

#### モック

モックは、SUTからSUTが依存するオブジェクトに向かうコミュニケーションを模倣するオブジェクトです。
モックは、メソッドの呼び出し回数や引数を記録して後で検証できます。

モックは、テストフレームワークを利用して作成することがほとんどで、pythonでは`unittest.mock.Mock`または`unittest.mock.MagicMock`クラスを利用できます。
`unittest.mock.MagicMock`クラスは、`unittest.mock.Mock`クラスのすべての機能と、`__getitem__`などの`マジックメソッド`を自動的にモックします。

単体テストでは、個々の機能を分離して1つの振る舞いをテストします。

例えば、実際にデータベースにアクセスしてユーザーの数を取得する`retrieve_number_of_users`関数があったとします。
そして、`UserQuery`クラスの`number_of_users`メソッドは、そのメソッドの内部で`retrieve_number_of_users`関数を呼び出しているとします。

`UserQuery`クラスの`number_of_users`メソッドをテストする場合、内部で呼び出す`retrieve_number_of_users`関数が色々な値を返すとテストがしにくくなります。
よって、`UserQuery`クラスの`number_of_users`メソッドが呼び出す`retrieve_number_of_users`関数をモックして、あらかじめ予期したデータを返却するようにします。

`retrieve_number_of_users`関数、`UserQuery`クラスとそのテストクラスは、`magic_mock`モジュールを参照してください。

ここで、`magic_mock/__main__.py`では、`magic_mock.user_query`の名前空間にインポートした、`retrieve_number_of_users`という名前で参照できる関数をモックしていることに注意してください
(`magic_mock`名前空間に存在する実際の`retrieve_number_of_users`関数をモックしているわけではありません)。

```python
import unittest
from unittest.mock import MagicMock

import magic_mock.user_query  # <- ここ
from magic_mock.user_query import UserQuery


class UserQueryTest(unittest.TestCase):
    """ユーザークエリテストクラス"""

    def test_number_of_users(self) -> None:
        # snip

        magic_mock.user_query.retrieve_number_of_users = MagicMock( # <-- ここ
            return_value=100
        )

        # snip
```

#### スタブ

`スタブ`は、SUTが依存するオブジェクトからSUTに向かうコミュニケーションを模倣するオブジェクトです。
`スタブ`は、SUTに対して固定の応答を返すため、SUTの振る舞いをテストしやすくなります。
`スタブ`は、開発者が実装する必要があります。

```python
class ApiStub:
    def fetch(self) -> Dict:
        return {"data": "sample data"}


class FooTest(unittest.TestCase):
    def test_fetch_data(self) -> None:
        api = ApiStub()
        foo = Foo(api)
        result = foo.fetch_data()
        self.assertEqual(result, {"data": "sample data"})
```

### コマンド・クエリ分離の原則 (CQS: Command Query Separation)とモックとスタブ

`コマンド・クエリ分離の原則`とは、関数やメソッドは、何かをする`コマンド`か、問い合わせする`クエリ`のどちらかのみを実行して、両方を実行するべきではないという原則です。
コマンド・クエリ分離の原則を守ることで、関数やメソッドが何をするかを明確にすることができます。

- コマンド: データを変更するなど**副作用を起こして、戻り値がない**
- クエリ: データを変更するなどの**副作用を起こさないで、問い合わせた結果を返す**

よって、SUTが依存しているコマンドに該当する関数やメソッドは、`モック`を使用してテストします。
また、SUTが依存しているクエリに該当する関数やメソッドは、`スタブ`を使用してテストします。

## 単体テストの手法

単体テストには、次の3つの手法があります。

- `出力値ベーステスト`
- `状態ベーステスト`
- `コミュニケーションベーステスト`

単体テストの4つの柱のうち、退行に対する保護、迅速なフィードバックの2つは、単体テスト手法で差がありません。
**リファクタリングへの耐性と保守のしやすさは、3つの手法で差があり、最も備えるのは出力値ベーステストで、最も備えないのはコミュニケーションベーステストです**。

### 出力値ベーステスト

出力値ベーステストとは、テスト対象オブジェクトに入力値を与え、テスト対象オブジェクトから返される結果を検証するテストです。
出力値ベーステストは、テスト対象オブジェクトやその協力者オブジェクトなどの状態が変わらず、協力者オブジェクトのコミュニケーションがない場合に適しています。

出力値ベーステストは、他の2つの手法と比較して**最もリファクタリングへの耐性が高くなります**。

### 状態ベーステスト

状態ベーステストは、テスト対象オブジェクトの処理が完了した後、次に発生した状態などの副作用を検証する場合に適しています。

- テスト対象オブジェクト
- 協力者オブジェクト
- データベースやファイルシステムなどのプロセス外依存

状態ベーステストは、副作用の発生を検証するなど、プロダクションコードの実装と結びつきやすくなります。
よって、出力値ベーステストと比較して、壊れやすく、リファクタリングへの耐性が低くなります。

### コミュニケーションベーステスト

コミュニケーションテストは、モックを使用してテスト対象システムとその協力者オブジェクトとのコミュニケーションを検証します。
ここにおけるコミュニケーションとは、協力者オブジェクトのメソッドの呼び出し回数、メソッドの引数、戻り値などを指します。

コミュニケーションベーステストは協力者オブジェクトのコミュニケーションを検証するため、プロダクションコードの実装と結びつきが強くなります。
よって、コミュニケーションベーステストは、他の2つの手法と比較して、**最も壊れやすく、リファクタリングへの耐性が低くなります**。

## 関数型アーキテクチャ

状態ベーステストやコミュニケーションベーステストは、壊れやすく、リファクタリングへの耐性が低いため、これらのテストを可能な限り出力値ベーステストに変更することが望ましいです。

### 関数型プログラミング

`関数型プログラミング`は、`React`のコンポーネントがクラスコンポーネントから関数コンポーネントに置き換えられたように、注目されているプログラミングパラダイムです。
関数型プログラミングは、$y = x^2$など`数学的関数`を用いたプログラミングで、数学的関数は`純粋関数`とも呼ばれます。
純粋関数は、次の特徴があります。

- 隠れた入力や出力を持ちません。
- 同じ入力に対しては、常に同じ出力を返します。
- 状態を変更したり、状態に依存するなど、`副作用`がありません。

純粋関数のすべての入力と出力は、関数の引数と戻り値で表現されています。

```python
# 純粋関数
def add_two_numbers(x: int, y: int) -> int:
    return x + y

# 純粋関数は予測可能で、何回実行しても同じ結果
assert add_two_numbers(1, 2) == 3
assert add_two_numbers(1, 2) == 3

# 副作用がある関数
# a, bは、add_something関数の隠れた入力で、出力に影響を与える
# また、add_something関数は、a, bを変更する副作用がある
a = 1
b = 2
def add_something(x: int) -> int:
    global a
    global b
    result = x + a + b
    a += 1
    b += 1
    return result

# 帛紗硫黄がある関数は予測が難しく、実行するたびに結果が変わる可能性がある
print(add_something(1))  # 4
print(add_something(1))  # 6
```

隠れた入力と出力には次があります。

- 副作用
- 例外
- 内部もしくは外部の状態の参照

書籍では例外を隠れた出力として扱われていますが、出力値ベーステストで例外を考慮することで特別視する必要はないと考えています。

> クラスやインスタンスメソッドは、基本的にクラスまたはインスタンスの状態に依存するため、純粋関数ではありません。
> それらの状態に依存しないメソッドである場合、メソッドではなく単なる関数として実装した方が良いと考えられます。

### 関数型アーキテクチャ

システムは、ユーザーの情報を記録したり、注文を受け付けて記録するため、副作用なしで構築することは不可能です。
関数型プログラミングの目的は、副作用を完全に取り除くことではなく、**ビジネスロジックを扱うコードと副作用を扱うコードを分離**することです。

`関数型アーキテクチャ`は、可能な限り副作用を処理の最初と最後に移動して、その間にビジネスロジックを配置します。
例えば、関数型アーキテクチャでは、次の順書で処理をします。

1. ビジネスロジックに必要なすべてのデータをデータベースから取得します（状態依存、隠された入力）。
2. ビジネスロジックを実行します（純粋関数）。
3. ビジネスロジックが判断した結果をデータベースに保存します（副作用、隠された出力）。

### 出力値ベーステーストへの移行

#### サンプルプロジェクト（訪問者記録システム、vls: Visitor Logging System）

訪問者記録システムは次の仕様です。

- テキストファイルに訪問者と訪問日時を1行ずつ記録します。
- 最新の訪問者はテキストファイルの最後に記録します。
- テキストファイルに記録されている訪問者の数が上限に達していた場合、新しいテキストファイルに訪問者を記録します。
- 訪問者を記録するテキストファイルは、`visitor_0001.txt`のようにファイルのインデックスをファイル名に含めます。

訪問者記録システムの最初のバージョンは`vls1`モジュールを参照してください。

現在の`VisitorManager`クラスには次の問題があります。

- `VisitorManager`がファイルシステムと`密結合`しており、テストの実装が煩雑になるため、保守のしやすさが得られません。
- テストを実行する前に、訪問者記録ファイルを正しく配置する必要があります。
- テスト終了後に、訪問者記録ファイルを削除する必要があります。
- ファイルシステムは、管理下にないプロセス外依存であるため、並行または並列に実行できません。
- また、テストでファイルシステムを扱う必要があるため、若干、迅速なフィードバックが得られなくなっています。

| 良い単体テストの4本の柱  | 最初のバージョンのテスト |
| ------------------------ | ------------------------ |
| 退行に対する保護         | 良い                     |
| リファクタリングへの耐性 | 良い                     |
| 迅速なフィードバック     | 普通                     |
| 保守のしやすさ           | 悪い                     |

なお、ファイルシステムを扱うテストは、単体テストではなく、統合テストに分類されます。

#### ファイルシステムをスタブ／モックに置き換える

テストがプロセス外依存と密結合している場合、プロセス外依存をスタブやモックに置き換えることで、問題を解決できます。
この場合、プロダクションコードに含まれるファイルシステムに対する操作を`IFileSystem`インターフェイスとして抽出します。
そして、`IFileSystem`インターフェイスを実装するインスタンスを、`VisitorManager`クラスのコンストラクタ（pythonの場合はイニシャライザ）に`注入`するようにリファクタリングします。

これにより、型に厳密なプログラムのプロダクションコードでは`IFileSystem`を実装して、実際にファイルシステムを操作するインスタンスに、単体テストでは`IFileSystem`インターフェイスを実装したモックに置き換えられるようにします。
そして、単体テストでは、モックを介して、訪問者記録ファイルへの書き込みを検証します。

> インターフェイスを介すことでクラスが具体的に依存するのではなく**抽象**に依存するようになります。
> これは、[SOLID原則](https://qiita.com/baby-degu/items/d058a62f145235a0f007)の`依存関係逆転の原則`に該当します。
> そして、依存関係を後から注入することを`DI (Dependency Injection)`と呼びます。

pythonでは、`unittest.mock.MagicMock`を使用する場合、モックに`IFileSystem`インターフェイスを実装する必要はありません。
静的型付け言語では、プロセス外依存にインターフェイスを導入して、プロセス外依存を扱うクラスとそのモックにそのインターフェイスを実装する必要があります。

訪問者記録システムに`IFileSystem`インターフェイスを導入した`vls2`モジュールを参照してください。
また、ファイルシステムをモックに置き換えた単体テストは、`vls2/test_visitor_manager.py`を参照してください。
`vls2`モジュールでは、pythonで`abc`モジュールを利用してインターフェイスを実装する例を示していますが、本来必要のないものです。

単体テストでファイルシステムをモックに置き換えたことで、さらに単体テストから迅速なフィードバックが得られるようになり、単体テストの保守のしやすさも向上しました。
しかし、出力値ベーステストと比較して、単体テストの読みやすさは向上していません。

| 良い単体テストの4本の柱  | 最初のバージョンのテスト |
| ------------------------ | ------------------------ |
| 退行に対する保護         | 良い                     |
| リファクタリングへの耐性 | 良い                     |
| 迅速なフィードバック     | 良い                     |
| 保守のしやすさ           | 普通                     |

ただし、インターフェースを導入して、外部依存をモックに置き換えることで、単体テストを実装しやすくなることを紹介したまでであることにに注意してください。
ここで、実装した単体テストは、検証に成功することが当然であるため、プロダクションコードの品質の向上にまったく役にたっていません。

**外部依存をモックして単体テストの品質が向上しないと判断した場合は、単体テストを実装せず、実際の外部依存を使用した統合テストを実装してください**。

#### 関数型アーキテクチャへのリファクタリング

`VisitorManager`クラスから、副作用を完全に取り除き、`VisitorManager`がビジネスロジックのみを実行するようにリファクタリングします。
`VisitorManager`クラスに判断するために必要な情報を取得したり、実際のファイルシステムに副作用を与える機能は、新たに作成する`VisitorRecordService`クラスに委譲します。

これにより、**ビジネスロジックと、発生する副作用を分離**することができます。
ビジネスロジックを担う`VisitorManager`クラスには、保守しやすい出力値ベースの単体テストを実装します。
また、副作用を伴う`VisitorRecordService`クラスには、統合テストを実装します。

| 良い単体テストの4本の柱  | 最初のバージョンのテスト |
| ------------------------ | ------------------------ |
| 退行に対する保護         | 良い                     |
| リファクタリングへの耐性 | 良い                     |
| 迅速なフィードバック     | 良い                     |
| 保守のしやすさ           | 良い                     |

#### 関数型アーキテクチャを採用できないテストケース

実際のプロダクションコードには、例えば、ビジネスロジックを処理している間に、途中で得た結果を使用して、外部依存からデータを取得する必要があるなど、ビジネスロジックを処理する前にビジネスロジックに必要なすべてのデータを得られない場合があります。

単体テストに関数型アーキテクチャを採用できるのは、テスト対象オブジェクトが純粋関数の場合のみです。

よって、関数型アーキテクチャを採用できないテストケースでは、モックでそのような外部依存を置き換える必要があります。
すべての単体テストを出力値ベーステストにするのではなく、可能な限り多くの出力値ベーステストを実装することが推奨されます。

## リファクタリング

テストの実装が煩雑になる場合、プロダクションコードの設計に問題がある可能性があります。
この場合、プロダクションコードをリファクタリングする必要があります。

### リファクタリングが必要なコードの識別

プロダクションコードは、次の2つの指標で分類できます。

- **コードの複雑さ、ドメインにおける重要性**
- **協力者オブジェクトの数**

コードの複雑さは分岐の数で計測します。
ドメインにおける重要性は、テスト対象コードがドメインにおいてどれだけ重要かで判断します。

上記指標で、プロダクションコードは、次の4つに分類できます。

- `ドメインモデル／アルゴリズム`
- `取るに足らないコード`
- `過度に複雑なコード`
- `コントローラー`

![プロダクションコードの分類](./images/classification-of-production-code.png)

#### ドメインモデル／アルゴリズム

ほとんどの場合、ドメインモデルには複雑なコードが含まれています。
また、ドメインの問題領域以外で、複雑なアルゴリズムをもつコードがあります。
ドメインモデル／アルゴリズムに該当するコードに実装した単体テストは、他に分類されたコードよりも**高い価値を持ちます**。

#### 取るに足らないコード

取るに足らないコードに該当するコードに実装した単体テストは、**ほとんど価値がありません**。
取るに足らないコードは、単体テストを実装する必要はありません。

#### コントローラー

コントローラーに該当するコードは、複雑なことやドメインに関することを行わないコードですが、多くの協力者オブジェクトが適切に連携するように調整します。
コントローラーに該当するコードに実装した単体テストは、**価値があります**。

コントローラーに該当するコードは、単体テストではなく統合テストを実装することを検討してください。

#### 過度に複雑なコード

過度に複雑なコードは、ドメインにおける重要なコードであり、多くの協力者オブジェクトを使用します。

過度に複雑なコードは、テストすることが最も難しいコードです。
また、過度に複雑なコードをテストしないと、SUTが正常に動作しない可能性が高まり、リスクが高くなります。
このジレンマを解消するためには、過度な複雑なコードをリファクタリングして、ドメインモデル／アルゴリズムまたはコントローラーになるようにコードを分割します。

#### 質素なオブジェクト (Humble Object) を利用した過度に複雑なコードの分割

テストすることが難しくなるのは、非同期や複数スレッドの実行、UI、データベースなどのプロセス外依存とのコミュニケーションなどを担うフレームワークに直せず結びついた依存です。
このような依存と結びついたコードをテストするためには、そのコードから**テストしやすい部分を抽出**します。
そして、抽出した部分を担う**質素なオブジェクト (Humble Object)** をクラスとして実装して、その質素なクラスとテストすることが難しい依存を結びつけます。
このとき、質素なクラスに対してロジックをほぼ含まないようにすることで、質素なクラスをテストする必要がなくなるようにします。

![質素なオブジェクト](./images/humble-object.png)

質素なオブジェクトを作成することで、過度に複雑なコードからロジックを抽出できるようになります。
質素なオブジェクトが抽出されたロジックは、テストすることを難しくする依存から切り離しできます。
質素なオブジェクトを利用するパターンを利用することで、**ビジネスロジックをすべてのものから隔離**できるようになります。

> 質素なオブジェクトは、[SOLID原則](https://qiita.com/baby-degu/items/d058a62f145235a0f007)の`単一責任の原則`に該当します。

#### サンプルプロジェクト (ユーザー管理システム) について

ユーザー管理システムを例に、過度に複雑なコードを質素なオブジェクトを利用してロジックと外部依存を分離して、質素なオブジェクトを介してロジックと外部依存をコミュニケーションさせる方法を紹介します。

ユーザー管理システムの仕様は次のとおりで、ユーザーのメールアドレスを変更する機能を追加することが求められています。
なお、メッセージバスとは、異なるシステム間でメッセージをやり取りするための通信手段です。

- 登録されたユーザーを管理します。
- ユーザー情報はデータベースに格納します。
- ユーザーのメールアドレスに自社のドメイン名が含まれている場合、そのユーザーの種類を「従業員 (employee)」として登録します。
- ユーザーのメールアドレスに自社のドメイン名が含まれていない場合、そのユーザーの種類を「顧客 (customer)」として登録します。
- 登録されたユーザーのうち従業員の数を管理します。
- もし、ユーザーの種類が従業員から顧客に変更された場合、従業員の数を減らします。
- 逆に、もしユーザーの種類が顧客から従業員に変更された場合、従業員の数を増やします。
- メールアドレスを変更した後、メッセージバスにメッセージを送り、ユーザーのメールアドレスが変更されたことを外部システムに通知します。

最初のバージョンのユーザー管理システムは、`ums1`モジュールを参照してください。

最初のバーションの`User`クラスは、次の特徴があります。

- ビジネスロジックを含むため、ドメインにおける重要性が高いです。
- プロセス外依存かつ協力者オブジェクトであるデータベースとメッセージバスを扱っています。
- ドメインにおける重要性が高く、協力者オブジェクトが多いため、過度に複雑なコードに分類されます。

`django`や`rails`のように、ドメインクラスがデータベースから自身のデータを取得したり保存できるようにする設計パターンを`アクティブレコードパターン`と呼びます。

アクティブレコードパターンは、シンプルな`CRUD (Create Reference Update Delete)`なシステムではうまく機能します。
しかし、コードベースが大きくかつ複雑になると、**ビジネスロジックとプロセス外依存とのコミュニケーションが分離できなくなり、システムの成長が阻害される**場合があります。

#### ユーザー管理システムのリファクタリング

最初のバージョンの`User`クラスは、ビジネスロジックとプロセス外依存が混在しています。また、ユーザーと異なる概念である会社をデータベースから取得する機能を実装しています。

最初のバージョンの`User`クラスは、過度に複雑なコードに分類されるため、次のとおりリファクタリングします。

- `User`クラスはドメインモデルであるため、プロセス外依存を扱うコードを削除します。最初のバージョンの`User`クラスには、プロセス外依存を扱う次のコードがあります。
  - データベースからユーザーを取得するコード
  - データベースにユーザーを記録するコード
  - データベースから会社を取得するコード
  - データベースに会社を記録するコード
  - メッセージバスにユーザーのEメールアドレスの変更を通知するコード
- ユーザーを操作するために必要な情報は、`User`クラスのメソッドの引数として渡すようにします。
- ユーザーのEメールアドレスの変更と会社の従業員数の更新を仲介して、プロセス外依存を扱う`UserService`クラスを質素なオブジェクトとして追加します。
  - 質素なオブジェクトである`UserService`クラスを導入することで、ビジネスロジックとプロセス外依存を分離して、ビジネスロジックをドメインクラスに配置して、ドメインクラスを十分にテストできるようにします。

リファクタリングのユーザー管理システムは、`ums2`モジュールを参照してください。

それぞれのクラスがどのコードに分類されるかを次に示します。

- ドメインモデル／アルゴリズム
  - `User`, `Company`,
- コントローラー
  - `UserService`
- 取るに足らないコード
  - `Repository`, `MessageBus`

リファクタリングにより、過度に複雑なコードが分割され、他のコードに分類されるようになります。
そして、ドメインモデル／アルゴリズムに分類されたコードに対して単体テストを実装して、コントローラーに分類されたコードに対して統合テストを実装します。

りファクタリングにより取るに足らないコードに分類されたコードは、データベースやメッセージバスなどのプロセス外依存になり、おそらくフレームワークやライブラリを利用した単純なコードを実装することになります。
これらのコードをテストしても、フレームワークやライブラリをテストすることになるため、テストを実装しなくても良いと考えられます。

データベースは管理下にあるプロセス外依存、メッセージバスは管理下にないプロセス外依存として扱われます（扱うことにします）。
よって、コントローラの統合テストでデータベースを直接扱い、メッセージバスをモックに置き換えることで、テストは十分だと考えられます。

### ドメインイベントの導入

リファクタリング後のユーザー管理システムには、ユーザーのEメールアドレスが変更されなかった場合も、`UserService`がメッセージバスでユーザーのEメールアドレスの変更を通知する不具合があります。
しかし、`UserService`で現在のパスワードと新しいパスワードが異なっていることを確認するコードを実装することは、ビジネスロジックが`UserService`に漏洩することになり、もしビジネスロジックが変更された場合、漏洩した箇所すべてを変更する煩雑さと、変更忘れなどのリスクがあり、保守しやすさが失われます。

ビジネスロジックを漏洩させず、保守しやすさを損なわないように不具合を解消するためには、`ドメインイベント`を導入して、外部からドメインで発生したイベントを観測可能にします。

ドメインイベントを導入したユーザー管理システムは、`ums3`モジュールを参照してください。

`ums`では、ユーザーに発生したドメインイベントを識別する`UserEventType`列挙型、ユーザーに発生したイベントを表現する`UserEvent`クラスを追加しました。
`UserEvent`クラスには、イベントの詳細を辞書で記録する`event_data`フィールドがあります。

また、`User`クラスに、ユーザーに発生したドメインイベントを管理する`UserEvent`リストを追加しました。

さらに、`UserService`クラスの`change_email`メソッドを、実際にユーザーのEメールアドレスが変更されたときのみ、メッセージバスにその旨を通知するように修正しました。

`ums3`の`UserService`クラスの実装は、ユーザーのEメールアドレスが変更されたかどうかに関わらず、ユーザーと会社をデータベースに保存するため、不必要なパフォーマンスの劣化が発生することがあります。
しかし、ユーザー管理システムにおいて、最終的にユーザーと会社の情報が正しく記録されていることが重要であるため、これを許容します。
これは、実際にユーザーのEメールアドレスが変更されたときのみ、メッセージバス経由で退部システムに通知する要件とは異なっています。

## 統合テスト (integration test)

統合テストは、**システム全体が意図した通りに動作するかを検証**するテストです。
単体テストは、ビジネスロジックを検証るすために優れていますが、**ビジネスロジックとプロセス外依存とのコミュニケーションを検証するためには、統合テストが必要**です。

単体テストの性質を再度示します。
統合テストは、単体テストの性質を1つでも満たさないテストに該当します。

- 1単位の振る舞いを検証すること
- 実行時間が短いこと
- 他のテストケースから隔離された状態で実行されると

統合テストは、コードの4つの分類の内、コントローラーに該当するコードを対象に実装します。
ただし、コントローラーに該当するコードであっても、統合テストとして実装したとき、すべてのプロセス外依存をモックに置き換えた場合、それは単体テストに該当します。

統合テストは、単体テストよりも保守コストが高くなります。
一方、統合テストは、単体テストよりも多くのプロダクションコードを実行するため、**単体テストよりも対抗に対する保護が備わります**。
また、統合テストは、ユーザーのユースケースをブラックボックステストするため、単体テストよりもプロダクションコードへの結びつきが弱くなり、**単体テストよりもリファクタリングへの耐性が備わります**。

### 統合テストの実装

統合テストは、**すべてのプロセス外依存とのやり取りを検証できる長いハッピーパス**で実装します。
もし、そのようなハッピーパスが見つからない場合、すべてのプロセス外依存とやり取りできるまでテストケースを増やします。

一般的に、**統合テストは、１件のハッピーパスと単体テストでは検証できないすべての異常ケースを検証**します。

また、一般的に、統合テストのテストケースは、テストピラミッドが示す通り、単体テストよりも少なくなります。
ただし、単純なCRUDシステムの場合、ほぼすべてのコードが取るに足らないコードに分類されるため、統合テストと単体テストのテストケースの数が同じくらいになることもあります。

### 統合テストと早期失敗 (Fail First)

何かを処理する前に必ず検証する`確認後実行 (CanExecute / Execute) パターン`をビジネスロジックで実装している場合、その異常ケースを統合テストで実装する必要はありません。

確認後実行パターンでは、処理する前に処理ができるか確認して、処理できないと判断した場合は、即座に処理を失敗させます。
これを`早期失敗 (Fail First)`と呼びます。

```python
class User:
    def can_change_email(self, new_email: str) -> bool:
        """Eメールアドレスを変更できる場合はTrue、変更できない場合はFalseを返す"""
        pass

    def change_email(self, new_email: str) -> None:
        """確認後実行パターンを適用したEメールアドレスを変更"""
        # Eメールアドレスを変更できるか確認
        if not self.can_change_email(new_email):
            raise ValueError()
        # Eメールアドレスを変更できることを確認できたため、Eメールアドレスを変更
        self.email = new_email

class UserService:
    def change_email(self, user: User, new_email: str) -> None:
        """ユーザーのEメールアドレスを変更"""
        if user.can_change_email(new_email):
            user.change_email(new_email)
```

上記の場合、ユーザーのEメールアドレスを変更できない場合の振る舞いを検証する統合テストには、あまり価値はありません。
仮に、`UserService`クラスで、Eメールアドレスを変更できるか確認するメソッドを呼び出すことを忘れていても、`User`クラスの`change_email`メソッドが失敗するため、Eメールアドレスを変更する処理が中断されます。
また、確認するメソッドの呼び出しを忘れたコードが本番環境に持ち込まれても、処理が失敗するため、データが破壊されることはありません。

ただし、上記の通り**確認後実行パターンを適用しているコードに対する統合テストの省略は、単体テストで十分にテストされていることが前提です**。

### 統合テストにおけるプロセス外依存の取り扱い

再度、プロセス外依存の種類を示します。

- 管理下にある依存
  - テスト対象アプリケーション専用のデータベースなど、テスト対象アプリケーションが単独で自由に取り扱える依存
  - この依存にアクセスするためには、必ずテスト対象アプリケーションを経由しなくてはならない
  - 上記理由で、テスト対象アプリケーションとこの依存との**コミュニケーションを外部から確認できない**
- 管理下にない依存
  - 外部のメールサービスなど、テスト対象アプリケーションが単独で自由に取り扱えない依存
  - テスト対象アプリケーションとこの依存との**コミュニケーションを外部から確認できる**

統合テストにおいて、**管理下にある依存は実際のインスタンスを使用**します。
また、**管理下にない依存はモックに置き換え**ます。

#### 管理下にある依存と管理下にない依存の両方の性質を持つプロセス外依存の取り扱い

管理下にある依存と管理下にない依存の両方の性質を持つプロセス外依存もあります。
代表的な事例として、複数のシステムによるデータベースのテーブルの共有があります。

そもそも、データベースのテーブルの共有は、それぞれのシステムが密結合してしまい、単独で改修することを難しくします。
複数システムによるデータベースのテーブルの共有は、**悪きプラクティス**です。

複数システムによるデータベースのテーブルの共有が避けられない場合、他のシステムからアクセスされないテーブルを管理下にある依存、アクセスされるテーブルを管理下にない依存として扱います。

#### 統合テストで実際のデータベースを利用できない場合

統合テストで実際のデータベースを利用できない場合、**統合テストを実装するべきではありません**。

統合テストでデータベースをモックに置き換えても、統合テストからリファクタリングへの耐性が失われます。
また、リファクタリングへ耐性がないテストは、対抗に対する保護も失われます。

### 統合テストの作成

統合テストも、単体テストと同様にAAAパターンで実装します。
ただし、統合テストは、単体テストよりも準備するデータが多くなり、検証する内容も多くなります。
このため、統合テストでは、**統合テスト間でデータを準備する処理や検証する処理を共通化するためにヘルパー関数を作成する**ことが推奨されます。

### 参考: 静的型付け言語におけるインターフェイスを利用したプロセス外依存の抽象化

**テストにおいて**インターフェイスを導入してプロセス外依存を抽象化する理由は、**プロセス外依存を扱うクラスとそのモックに同じインターフェイスを実装して、単体テストでプロセス外依存をモックに置き換えるため**です。
よって、**プロセス外依存を扱う単体テストを実装せず、統合テストでプロセス外依存をモックする必要がない場合、その依存のインターフェイスは必要ありません**。

管理下にない依存は、統合テストでモックする必要があるため、その依存のインターフェイスを導入します。

### 1つのテストケースで複数の実行フェーズを持つ統合テスト

単体テストと同様に、統合テストにおいて1つのテストケースに複数の実行フェーズがある場合、何を検証するテストケースかを判断することが難しくなります。
例えば、ユーザーの登録と削除を確認する統合テストでは、次のような実行フェーズがあるかもしれません。

1. 準備: ユーザーを登録するために必要なデータを準備
2. 実行: ユーザーを登録
3. 確認: ユーザーが登録されたことを確認
4. 実行: 登録したユーザーを削除
5. 確認: ユーザーが削除されたことを確認

ユーザーを削除する統合テストでは、削除するユーザーを事前に登録する必要があるため、この統合テストは妥当と考えるかもしれません。
しかし、この統合テストは、ユーザーのユースケースをテストしておらず、何を検証するテストケースかが曖昧です。
**統合テストは、ユーザーのユースケースに従って作成する**必要があります。

よって、この場合、ユーザーを登録するテストケースとユーザーを削除するテストケースに分割する必要があります。
ユーザーを削除するテストケースでは、ヘルパ関数を作成して、容易にユーザーを登録できるようにします。
おそらくこのようなヘルパ関数は、他のテストケースでも利用されることになるため便利になります。

### ログの出力テスト

#### ログの分類

システムが出力するログは次の2つに分類されます。

- サポートログ
  - システム運用者はシステム管理者が、システムで発生した特定のイベントを記録するログ
- 診断ログ
  - 開発者がシステムで発生した状況を把握するために記録するログ

サポートログは、ビジネス要求であり、ファイルシステムなどに副作用を発生させる観測可能な振る舞いであるため、統合テストを作成する必要があります。
また、診断ログは、実装の詳細であるため統合テストを作成する必要はありません。

なお、システムがサポートログを出力する必要がある場合、サポートログと診断ログを別に出力することが望ましいです。
よって、サポートログは専用のクラスを作成して、そのクラスを利用して出力するようにして、診断ログはログフレームワークを利用して出力することもできます。

#### サポートログの出力

サポートログの出力は、副作用を発生させるため、ドメインオブジェクトでログを直接出力すると、ドメインオブジェクトのコードが過度に複雑なコードに分類されることになります。

よって、ユーザー管理システムに導入したドメインイベントと同様に、コントローラーでドメインイベントに発生したイベントを確認して、サポートログを出力するようにします。

#### 診断ログの出力

診断ログの出力は、ロギングフレームワークを利用して出力します。

ドメインオブジェクトでロギングフレームワークを利用することは、ドメインオブジェクトとフレームワークが密結合することに繋がります。
しかし、ドメインオブジェクトとフレームワークを分離する理由は、ドメインオブジェクトをテストしやすくするためでした。
しかし、診断ログの出力はテストしませんし、ロギングフレームワークを変更しない限り、ドメインオブジェクトのコードに変更が発生しません。

ただし、単体テストまたは統合テストでは、モックなどを利用して、テストであまり必要とされない診断ログの出力を抑制することを推奨します。
