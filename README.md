# テストの考え方と実装方法 in Python

[単体テストの考え方／使い方](https://book.mynavi.jp/ec/products/detail/id=134252)

![書籍表紙](https://book.mynavi.jp/files/topics/134252_ext_06_0.jpg?v=1670578534)

本文書では、**古典学派 (デトロイト学派) の解釈を採用**しています。

- [テストの考え方と実装方法 in Python](#テストの考え方と実装方法-in-python)
  - [テストの種類](#テストの種類)
    - [単体テスト (Unit Test) の概要](#単体テスト-unit-test-の概要)
    - [統合テスト (Integration Test) の概要](#統合テスト-integration-test-の概要)
    - [E2E (End to End Test) の概要](#e2e-end-to-end-test-の概要)
  - [テストを実装する理由](#テストを実装する理由)
  - [共有依存 (shared dependency)](#共有依存-shared-dependency)
  - [プライベート依存 (private dependency)](#プライベート依存-private-dependency)
    - [プライベートな不変依存](#プライベートな不変依存)
      - [値オブジェクト (value object)](#値オブジェクト-value-object)
    - [プライベートな可変依存](#プライベートな可変依存)
  - [プロセス外依存](#プロセス外依存)
    - [管理下にある依存 (managed dependency)](#管理下にある依存-managed-dependency)
    - [管理下にない依存 (unmanaged dependency)](#管理下にない依存-unmanaged-dependency)
  - [テストの品質の維持](#テストの品質の維持)
  - [網羅率](#網羅率)
    - [コード網羅率 (code coverage)](#コード網羅率-code-coverage)
    - [分岐網羅率 (branch coverage)](#分岐網羅率-branch-coverage)
    - [網羅率をテストスイートの品質としてはいけない理由](#網羅率をテストスイートの品質としてはいけない理由)
  - [品質の良いテストスイートの条件](#品質の良いテストスイートの条件)
    - [テストすることが開発サイクルの中に組み込まれている](#テストすることが開発サイクルの中に組み込まれている)
    - [コードベースの特に重要な部分飲みがテスト対象になっている](#コードベースの特に重要な部分飲みがテスト対象になっている)
    - [最小限の保守コストで最大限の価値を生み出すようになっている](#最小限の保守コストで最大限の価値を生み出すようになっている)
  - [単体テスト](#単体テスト)
    - [単体テストに求められる要件](#単体テストに求められる要件)
    - [単体テストの構造](#単体テストの構造)
      - [1つのフェースが複数存在する場合](#1つのフェースが複数存在する場合)
      - [分岐がある場合](#分岐がある場合)
      - [実行フェーズが1行以上になる場合](#実行フェーズが1行以上になる場合)
      - [テスト後の後始末](#テスト後の後始末)
      - [テスト対象システムの変数名](#テスト対象システムの変数名)
      - [テスト対象の振る舞いの中に分岐がある場合](#テスト対象の振る舞いの中に分岐がある場合)
    - [単体テストの命名](#単体テストの命名)

## テストの種類

- 単体テスト (Unit Test)
- 統合テスト (Integration Test)
- E2Eテスト (End to End Test)

### 単体テスト (Unit Test) の概要

- **テストの実行が自動化**されていること
- **1単位の振る舞い (a unit of behavior)** を検証すること
- **実行時間が短い**こと
- **他のテストケースから隔離**して実行できること

単体テストでは、関数やクラスのメソッドなど、**1つの振る舞い**を検証します。

また、実行時間を短くすることで、**繰り返し単体テストを実行**できるように開発者の負担を軽減します。
実行時間が長くなると、開発者がテストを実行する回数が減り、バグを見つけるまでの時間が長くなります。
バグが見つかるまでの時間が長くなると、それまでにコードベースは大きくなるため、バグの特定と修正に時間がかかるようになります。

さらに、それぞれの単体テストが他の単体テストと独立することで、他の単体テストからの影響を受けず、個別に実行できるようになります。
これに、単体テストを**個別に実行**したり、同時に**複数の単体テストを並行／並列で実行**することができます。

### 統合テスト (Integration Test) の概要

`統合テスト`は、システム全体が意図したように機能することを検証するテストです。
システムの`ユースケース`ごとに、統合テストを実装して、それぞれまたは連続して実行します。

### E2E (End to End Test) の概要

`E2Eテスト`は、統合テストの上位に位置するテストです。
統合テストでは、システムが依存するメール送信サービスなどの外部サービスをテストダブルに置き換えますが、`E2Eテスト`では、ほぼすべての依存を実際のサービスを使用してテストします。

本文書では、`E2Eテスト`は説明の対象外とします。

## テストを実装する理由

テストを実装する理由は、システムが**将来も持続的に成長できるようにするため**です。
テストが実装されているシステムのことを`テスト対象システム (SUT: System Under Test)`と呼びます。

ほとんどのシステムは、リリース後に何度も仕様変更や改修が行われ、その中で`リファクタリング`されます。
テストが実装されているシステムの仕様変更や改修は、単体／統合テストを実行することで、変更がシステム全体に影響を与えないことを確認できます。
変更によりシステムに不具合が発生することを`退行 (regression)`と呼びますが、SUTは、退行を防ぐことができ、仕様変更や改修に対する開発者の負担を軽減します。

逆に、SUTでないシステムの変更は、変更がシステムに影響を与えたかを確認する工数が多くなり、開発者の負担が大きくなります。
この負担は、開発者のモチベーションを下げ、システムを変更しない理由となり、システムの成長を妨げるようになります。

システムのコードベースは、リリース後に成長しはじめ、劣化する傾向があるため、エントロピー（無秩序の量）が増大するため、リファクタリングが必要になります。
SUTは、退行を生み出す可能性が低くなり、リファクタリングに対する開発者の心理的不安をなくすことができます。

逆に、一時的に作成するプログラムなど、成長することがないシステムに対しては、簡易的なテストの実装で済ましたり、テストの実装を省くことができると考えられます。

![プロジェクトの成長](./images/project-growth.png)

## 共有依存 (shared dependency)

`共有依存 (shared dependency)`とはテストケースで共有される依存のことで、データベースなどがあります。
共有依存を扱うテストケースを同時に実行すると、お互いがテストに影響を与えるため、正常にテストが実行されなくなる場合があります。

単体テストにおいて、共有依存はテストダブルに置き換えられます。

## プライベート依存 (private dependency)

`プライベート依存 (private dependency)`とは、テストケースで共有されない依存で、`可変依存`と`不変依存`があります。

単体テストにおいて、プライベート依存は、1つのテスト対象オブジェクトからしか参照されないため、テストダブルに置き換えず、そのまま使用します。

### プライベートな不変依存

データが不変で、1つのテスト対象オブジェクトからしか使用されない場合、`プライベートな不変依存`となります。
プライベートな不変依存には、`値オブジェクト (value object)`などがあります。

#### 値オブジェクト (value object)

`ドメイン駆動設計 (Domain Driven Design: DDD`における値オブジェクトは、次の特徴を持ちます。

- 不変 (immutable: イミュータブル)
- 同一性を持たない (IDや識別子を持たない)
  - 同じ属性を持つ値オブジェクトは等価である
- 小さい属性の集合

`value_objects`モジュール、住所を表現する値オブジェクトをクラスで、色を表現する値オブジェクト列挙型で示します。

### プライベートな可変依存

データが可変で、1つのテスト対象オブジェクトからしか参照されない場合、`プライベートな可変依存`となります。
プライベートな可変依存には、ファイルシステムに作成された、1つのテスト対象オブジェクトからしか参照されないファイルなどがあります。

## プロセス外依存

システムは、データベースやメール配信サービスなど、システムが動作するプロセス以外で動作する依存があります。
この`プロセス外依存`は、次の2つに区分されます。

- 管理下にある依存 (managed dependency)
- 管理下にない依存 (unmanaged dependency)

### 管理下にある依存 (managed dependency)

`管理下にある依存`は、SUTしかアクセスしないデータベースなど、SUTが自由に操作でき、その振る舞いを確認できる依存を示します。

単体テストでは、管理下にある依存をテストダブルで置き換え、テストの実行時間を短くします。
一方、統合テストでは、管理下にある依存を実際に利用したテストを実装します。

### 管理下にない依存 (unmanaged dependency)

`管理下にない依存`は、外部サービスなど、費用や過度に負荷を与えることができないなどの理由でSUTが自由に操作できない依存を示します。
管理下にない依存は、単体テスト及び統合テストでテストダブルに置き換えます。

## テストの品質の維持

テストの品質が悪いとは次の状態を指します。

- エラーが発生してテストを実行できない
- 偽陽性 (False Positive) が発生する
  - プロダクションコードが正しいにも関わらず、テストに失敗する
- 偽陰性 (False Negative) が発生する
  - プロダクションコードが誤っているにも関わらず、テストに成功する

テストの品質が悪いとテストが信頼されなくなり、テストが実行されません。
その結果、システムの持続的な成長が阻害されます。

よって、テストの品質を保つために次を心がける必要があります。

- プロダクションコードのリファクタリングに合わせて、テストをリファクタリングする。
- プロダクションコードを変更するたびにテストを実行する。
- テストが偽陽性や偽陰性を発生した場合は、修正する。

プロダクションコードがどのように振る舞うか理解するために、テストコードのリーディングは非常に有益です。
よって、プロダクションコードだけでなくテストコードも適切に保守する必要があります。

## 網羅率

テストスイート（テスト全体）の品質を評価する指標として`網羅率`があります。
網羅率からは、**テストスイートの品質が悪いことを確認できますが、良いことを確認できない**ことに注意してください。

網羅率には次の2つがあります。

- `コード網羅率 (code coverage)`
- `分岐網羅率 (branch coverage)`

### コード網羅率 (code coverage)

`コード網羅率`は、テストスイートがプロダクションコードの行をどれだけ実行したかで計算されます。

$コード網羅率 = \frac{テストスイートが実行した行数}{プロダクションコードの行数}$

次の`is_string_long`関数のコード網羅率を考えます。

```python
def is_string_long(s: str) -> bool:   # 1
    if len(s) > 5:                    # 2
        return True                   # 3
    return False                      # 4

import unittest
class TestIsStringLong(unittest.TestCase):
    def test_is_string_long(self):
        result = is_string_long("abc")
        self.assertFalse(result)
```

上記の場合、`len(s)`は`3`であるため、1, 3, 4行目が実行され、コード網羅率は0.75 (3 / 4)になります。

しかし、`is_string_long`関数を次に変更したとき、コード網羅率は1.0になります。
プロダクションコードのリファクタリングによりテストの品質は向上していませんが、コード網羅率は0.75から1.0に向上しました。

```python
def is_string_long(s: str) -> bool:
    return True if len(s) > 5 else False
```

**コード網羅率はプロダクションコードの実装方法で結果が変わる**ため、コード網羅率だけでテストスイートの品質を判断することはできません。

### 分岐網羅率 (branch coverage)

`分岐網羅率`は、テストスイートがプロダクションコードに存在する分岐した経路を、どれだけ実行したかで計算されます。

$分岐網羅率 = \frac{テストスイートが実行した分岐数}{プロダクションコードの分岐数}$

リファクタリング前後の`is_string_long`関数の分岐網羅率はどちらも0.5です。

ここで、次のような関数の結果を評価しない**邪悪な**`確認不在のテスト`を実装すると、分岐網羅率は1.0になります。

```python
class TestIsStringLong(unittest.TestCase):
    def test_is_string_short(self):
        result = is_string_long("abc")

    def test_is_string_long(self):
        result = is_string_long("abcdef")
```

上記のテストは、`is_string_long`関数の分岐をすべて実行していますが、関数の結果である`result`を評価していません。

### 網羅率をテストスイートの品質としてはいけない理由

網羅率をテストスイートの品質としてはいけない理由は次の通りです。

- プロダクションコードの実装方法によってコード網羅率が変わる
- 分岐網羅率を増やすために、確認不在のテストが実装される

**網羅率でテストスイートの品質が悪いことを評価できます**。
しかし、逆に**網羅率はテストスイートの品質が良いことを評価できません**。

コード網羅率または分岐網羅率が0.6などの場合、テストされていないプロダクションコードが多く残っていることを示し、これはテストスイートの品質が悪いことを示します。

基本的に網羅率を高く維持されていれば、**テストされている**とみなせます。
しかし、網羅率を例えば85%以上に維持するなど、数値目標を設定することは、開発者に**人工的な目標**を設定することになり、テストスイートの品質を向上させることに繋がりません。

## 品質の良いテストスイートの条件

- テストすることが開発サイクルの中に組み込まれている
- コードベースの特に重要な部分のみがテスト対象になっている
- 最小限の保守コストで最大限の価値を生み出している

### テストすることが開発サイクルの中に組み込まれている

テストは常に実行されなければならず、テストの実行が開発サイクルの中に組み込まれていなくてはなりません。
理想的には、仮に変更が些細なことであっても、コードに変更を加えるたびにテストが実施されるようになっていることです。

リモートリポジトリの`develop`または`main`ブランチにプッシュされるたびに、CI/CDパイプラインが実行されるように設定することが望ましいです。

### コードベースの特に重要な部分飲みがテスト対象になっている

ほとんどのシステムにおいて、システムの核はビジネスロジックを含むコードで、それらは**ドメイン**または**ドメインモデル**と呼ばれます。
テストの実装及び実行に費やした時間が価値として効果的に得られるのは、ドメインに対するテストです。

逆に価値の低いコードには、次などが挙げられます。

- インフラに関するコード
- フレームワーク、ライブラリ、データベースまたは外部サービスなど依存関係に関するコード
- インターフェイスなど、構成要素同士を結びつけるコード

ドメインをテストしやすくするために、**ドメインは価値の低いコードと分離**する（関係を持たない）必要があります。

### 最小限の保守コストで最大限の価値を生み出すようになっている

単体テストにおいて、最小限の保守コストで最大限の価値を生み出すことは非常に難しいです。
これをできるようにするためには、次ができなくてはなりません。

- 価値のあるテストケースを認識できること
  - 逆に、価値の低いテストケースを認識できること
- 価値のあるテストケースを作成できること

## 単体テスト

### 単体テストに求められる要件

繰り返しになりますが、古典学派 (デトロイト学派) の解釈において、単体テストには次の要件があります。

- テストの実行が**自動化**されていること
- **1単位の振る舞い (a unit of behavior)** を検証すること
- **実行時間が短い**こと
- **他のテストケースから隔離**して実行できること

### 単体テストの構造

単体テストは、次で構成される`AAAパターン`で実装します。

- 準備 (Arrange)
- 実行　(Act)
- 検証　(Assert)

```python
# プロダクションコード
class Calculator:
    def add(self, a: int, b: int) -> int:
        return a + b
```

```python
# テストコード
import unittest
from calculator import Calculator
class CalculatorTest(unittest.TestCase):
    def test_add_two_numbers(self) -> None:
        # 準備 (Arrange)
        calculator = Calculator()
        a = 1
        b = 2

        # 実行 (Act)
        result = calculator.add(a, b)

        # 検証 (Assert)
        self.assertEqual(result, 3)
```

準備フェーズでは、テストケースの事前条件を満たすようにSUTとその依存の状態を設定します。

実行フェーズでは、メソッドや関数を呼び出しなど、SUTの振る舞いを実行します。
SUTから結果が返ってくる場合は、その結果を変数に格納します。

検証フェーズでは、SUTの振る舞いの結果が期待通りであるかを確認します。
振る舞いの結果には次などがあります。

- SUTからの戻り値
- SUTが振る舞った後の、SUTの状態
- SUTの振る舞った後の、協力者オブジェクトの状態
- SUTの振る舞った後の、協力者オブジェクトのメソッドまたは関数の呼び出し回数

#### 1つのフェースが複数存在する場合

1つのフェーズが複数存在するテストケースは、`1単位の振る舞い (a unit of behavior)`を検証していない可能性があります。
この場合、テストケースを分割して、1単位の振る舞いを検証するようにします。
テストケースを分割できない場合、そのテストは`結合テスト`として実装した方が適切な場合があります。

#### 分岐がある場合

分岐があるテストケースは、`1単位の振る舞い (a unit of behavior)`を検証していない可能性があります。
この場合、分岐の数だけテストケースを分割して、それぞれのテストケースと1単位の振る舞いを検証するようにします。

#### 実行フェーズが1行以上になる場合

通常、実行フェーズのコードは1行になるはずです。
もし、実行フェーズが複数行になった場合、SUTのメソッドなどのAPIが適切でないと考えられます。
この場合、SUTをリファクタリングして、それぞれのメソッドが1単位の振る舞いをするように改善します。

***テストを実装することが煩雑になる場合、SUTの設計が適切でない***と考えられます。

次の単体テストでは、実行フェースで購入と在庫の更新を行っています。
もし、開発者が購入するAPIを発行した後、在庫を更新するAPIを発行しなかった場合、次のドメイン`不変条件`が破られ、システムの在庫管理が破綻します。
なお、不変条件とは、常に成立しなくてはならない条件を示します。

$購入前の在庫数 = 購入後の在庫数 + 購入数$

よって、`Customer`クラスの`purchase`メソッドは、購入する商品、購入する商品数及び店舗を受け取り、そのメソッドの中で在庫の更新をする必要があると考えられます。

```python
# 実行フェーズが1行以上になり、SUTの設計が適切でないケース
class PurchaseTest(unittest.TestCase):
    def test_purchase_succeeds_when_enough_inventory(self) -> None:
        """在庫が十分にあるときに、購入が成功することを確認"""
        # 準備
        store = Store()
        store.add_inventory(Product.SHAMPOO, 10)
        customer = Customer()

        # 実行
        success = customer.purchase(store, Product.SHAMPOO, 5)
        store.remove_inventory(Product.SHAMPOO, 5)

        # 確認
        self.assertTrue(success)
        self.assertEqual(5, store.get_inventory(Product.SHAMPOO))
```

#### テスト後の後始末

単体テストでは、プロセス外依存とやり取りせず、テストダブルとやり取りするため、テスト後の後始末が必要にならないことがほとんどです。
後始末が必要なテストは、`統合テスト`として実装することを検討してください。

#### テスト対象システムの変数名

多くの依存を扱う単体テストでは、単体テストのコードでテスト対象システムと依存を区別することが難しくなる場合があります。
テスト対象システムには、`sut (System Under Test)`という変数を使用することを検討してください。

#### テスト対象の振る舞いの中に分岐がある場合

SUTの振る舞いの中に分岐がある場合、分岐の数だけテストケースを実装することになります。
このとき、準備フェースにおけるSUTや依存の準備が煩雑な場合、それぞれのテストケースで煩雑な準備をする必要があります。
これを避けるため、それらを準備するヘルパー関数を実装して、単体テストのコードが簡潔になるようにしてください。

### 単体テストの命名

単体テストの命名は次に従ってください。

- `ビジネスエキスパート`と呼ばれる問題領域に精通する非開発者が、どのようなことを検証しているかが伝わるような名前にする
- 英語で命名する場合は、`_`で単語を区切る
- 厳密な命名規則に縛られないようにする

過去には、`<メソッド名>_<事前条件>_<予期した結果>`のような命名規則があったようですが、この命名方法は実装の詳細に着目しており、振る舞いに着目していないため、適切ではありません。
特に、特定の振る舞いを検証していることを示唆することにならないため、SUTのメソッドや関数の名前をテスト名に含めるべきではありません。

```python
class CalculatorTest(unittest.TestCase):
    def test_add_two_numbers(self) -> None:
        """2つの数値を加算することを確認"""
        # テストコード

    def test_add_two_numbers_returns_sum(self) -> None:
        """2つの数値を加算した結果を返すことを確認"""
        # テストコード


class DeliveryDispatcherTest(unittest.TestCase):
    def test_delivery_with_invalid_date_should_be_considered_invalid(self) -> None:
        """無効な日付が指定された配達は不正だと見做されるべきであることを確認"""
        # テストコード

    def test_is_delivery_valid_invalid_date_returns_false(self) -> None:
        """is_delivery_validメソッドは無効な日付を渡したときFalseを返すことを確認"""
        # テストコード
```

上記、それぞれのテストクラスの1つ目の名前は、簡潔で振る舞いを表現しており適切な名前と考えられます。
しかし、それぞれのテストクラスの2つ目の名前は、実装の詳細を表現しており、ビジネスエキスパートがどのような振る舞いを検証しているか理解することは難しいと考えられます。

